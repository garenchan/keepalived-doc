软件设计
^^^^^^^^

Keepalived是用纯ANSI/ISO C编写的。该软件围绕一个中央I/O多路复用器进行连接，以提供实时网络设计。\
主要的设计重点是在所有元素之间提供同质的模块化。这就是创建核心库来删除重复代码的原因。\
目标是生成安全可靠的代码，确保生产的健壮性和稳定性。

为了确保健壮性和稳定性，守护进程被切分为3个不同进程：

* 一个极简的父进程，负责fork和监控子进程

* 两个子进程，一个负责VRRP框架，另一个负责健康检查

每个子进程都有自己的调度I/O多路复用器，这种方式优化了VRRP调度抖动，因为VRRP调度比健康检查更敏感/关键。\
这种拆分设计最小化了健康检查依赖库的使用，并将其自己的操作最小化到空闲主循环，以避免由自身引起的故障。

父进程监控框架称为watchdog，设计是每个子进程打开一个accept unix域套接字，然后在守护进程引导时，\
父进程连接到那些unix域套接字并向子进程发送周期性(5秒)的hello数据包。\
如果父进程无法向远程连接的unix域套接字发送hello数据包，则只需重启子进程。

这种看门狗设计提供了2个好处，首先从父进程发送到远程连接子进程的hello数据包是通过I/O多路复用器调度程序完成的，\
它可以检测子进程调度框架中的deadloop。第二个好处是通过使用sysV信号来检测死亡的子进程。运行时，您将看到如下的进程列表：::

    PID    111    Keepalived        < - 监视子进程的父进程
           112    \ _ Keepalived    < - VRRP子进程
           113    \ _ Keepalived    < - 健康检查子进程


内核组件
--------

Keepalived使用了4个Linux内核组件：

1. LVS框架：使用getsockopt和setsockopt调用来获取和设置套接字上的选项

2. Netfilter框架：支持NAT和Masquerading的IPVS代码

3. Netlink接口：在网络接口上设置和删除VRRP虚拟IP

4. 组播：VRRP通告发送到保留的VRRP组播组(224.0.0.18)


原子元素
--------

.. image:: images/software_design.png
